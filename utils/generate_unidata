#!/usr/bin/env escript
%% -*- erlang -*-

header() ->"
-module(ux_unidata_db).

-export([fetch/2, get_function/2, bool_fun/2, default_fun/3]).

get_function(w3, Value) -> 
    DefValue = false,
    default_fun(w3, Value, DefValue);
get_function(comp_tag, Value) -> 
    DefValue = false,
    default_fun(comp_tag, Value, DefValue);
get_function(ccc, Value) -> 
    DefValue = 0,
    default_fun(ccc, Value, DefValue);
get_function(is_upper, Value) -> 
    bool_fun(is_upper, Value);
get_function(is_lower, Value) -> 
    bool_fun(is_lower, Value);
get_function(is_compat, Value) -> 
    bool_fun(is_compat, Value);
get_function(type, Value) -> 
    DefValue = other,
    default_fun(type, Value, DefValue);
get_function(comment, Value) -> 
    DefValue = <<>>,
    default_fun(comment, Value, DefValue);
get_function(comp, Value) -> 
    DefValue = false,
    default_fun(comp, Value, DefValue);
get_function(decomp, Value) -> 
    DefValue = [],
    default_fun(decomp, Value, DefValue);
get_function(to_upper, Value) -> 
    DefValue = noop, % fun(C) -> C.
    default_fun(to_upper, Value, DefValue);
get_function(to_lower, Value) -> 
    DefValue = noop, % fun(C) -> C.
    default_fun(to_lower, Value, DefValue).

bool_fun(Type, skip_check) ->
    fun(C) ->
            ?MODULE:bool_fun(Type, C)
    end;
bool_fun(Type, C) ->
    case fetch(Type, C) of
        {C} ->
            true;
        _ -> false
    end.

default_fun(Type, skip_check, DefaultValue) ->
    fun(C) ->
            ?MODULE:default_fun(Type, C, DefaultValue)
    end;
default_fun(Type, C, DefaultValue) ->
   case fetch(Type, C) of
       skip when DefaultValue =:= noop
            -> C;
       skip -> DefaultValue;
       {C, Val} -> Val
    end.

".

tail() -> "fetch(_,_) -> skip.
".


build(InFileName, OutFilePath) ->
    OutFileName = OutFilePath ++ "/ux_unidata_db.erl",
    InFile = ux_unidata_parser:open_file(InFileName),
    {ok, OutFile} = file:open(OutFileName, [write]),
    ok = file:write(OutFile, header()),
    do_build(InFile, OutFile),
    ok = file:write(OutFile, tail()),
    ok.


do_build(InFile, OutFile) ->
    case file:read_line(InFile) of
        {ok, []} ->
            do_build(InFile, OutFile);
        {ok, Line} ->
            Data = delete_nr(delete_comments(Line)),
            case ux_unidata_parser_unidata:parse(Data) of
                skip ->
                    do_build(InFile, OutFile);
                {ok, Value} ->
                    {_T, {Char, _CT}} = lists:keyfind(type, 1, Value),
                    lists:foreach(
                      fun({Action, Result}) ->
                              WriteValue = io_lib:format("fetch(~p,~p) -> ~p;~n",
                                                         [Action,
                                                          Char, Result]),
                              file:write(OutFile, WriteValue)
                      end,
                      Value),
                    do_build(InFile, OutFile)
            end;
        eof -> ok
    end.

delete_nr(Str) -> [X || X <- Str, X =/= $\n, X =/= $\r].

delete_comments(Line) ->
    lists:reverse(do_delete_comments(Line, [])).

do_delete_comments([], Acc) -> Acc;
do_delete_comments([$# | _], Acc) -> Acc;
do_delete_comments([H|T], Acc) -> 
    do_delete_comments(T, [H|Acc]).


main([InFileName, OutFileName]) ->
 io:format("Generating unicode data erl file. ~p~n", [{InFileName, OutFileName}]),
 io:format("Current path: ~p~n", [os:cmd("pwd")]),
 ok = code:add_pathsz(["../ebin", "../deps/metamodule/ebin"]),
 build(InFileName, OutFileName),
ok;
main(_) ->
        io:format("Usage: generare_unidata <in-file-path> <out-file-path>~n~n",[]).
